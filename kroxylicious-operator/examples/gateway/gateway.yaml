#
# Copyright Kroxylicious Authors.
#
# Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0
#

---
# cluster level
apiVersion: gateway.networking.k8s.io/v1
kind: GatewayClass
metadata:
  name: my-kafka-gateway-class
spec:
  controllerName: kroxylicious.io/operator
  parametersRef:
    group: kroxylicious.io
    kind: GatewayClassConfig
    name:
    namespace:
---
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway # Proxy
metadata:
  name: my-kafka-gateway
spec:
  gatewayClassName: my-kafka-gateway-class # i.e. the above object
  listeners:
  - name: my-listener
    # hostname: ??? # ignored for kafka
    port: 9092
    protocol: kafka
    tls: # optional
      mode: Terminate #
      certificateRefs: # CertificateRefs contains a series of references to Kubernetes objects that contains TLS certificates and private keys.
        - kind: Secret
          name: my-tls-key
      frontendValidation:
        caCertificateRefs:
          - kind: Secret
            name: my-ca-certs # A single reference to a Kubernetes ConfigMap with the CA certificate in a key named ca.crt.
    allowedRoutes: # optional
      namespaces:
        - from: Same # All | Same | Selector
          # selector: ""
      kinds:
      - kind: KafkaRoute
  addresses: # optional
  - type: ???
    value: 1.2.3.4
  infrastructure: # optional
    ???
  backendTLS: # optional
    ???
---
apiVersion: kroxylicious.io/v1alpha1
kind: KafkaRoute # Like our Cluster
metadata:
  name: my-route
spec:
  parentRefs:
    - group: gateway.networking.k8s.io
      kind: Gateway
      #namespace: ?? # optional, default to the local namespace of the Route
      name: my-kafka-gateway
      sectionName: ?? # optional, the name of a Listener in the Gateway
      port: ??
  hostnames:
    - ""
  rules:
    - name: validate-and-encrypt
      matches: ??
      filters:
        - group: filter.kroxylicious.io
          kind: RecordValidation
          name: ??
        - group: filter.kroxylicious.io
          kind: RecordEncryption
          name: ??
      backendRefs:
        - group: ???
          kind: ??? # Kafka or Service
          name: ???
          namespace: ???
          port: ???
# The our operator would:
# 1. Watch for KafkaRoute's
# 2. Deref the parentRefs to get a Set<Gateway>
# 3. Deref the GatewayClass
# 4. Check that it's the controller for the Gateway class
# 5. Stand up a proxy/proxies for the Gateway(s) using the given filters etc.

# This is fine for bootstrap, but Gateway's "listeners" model doesn't natrually fit with
#  Kafka's networking model. We'd basically need a listener for each broker.
#  Unless we use the Rendenzvous model to decouple.
#  Or the operator just stands up broker Services as needed, even though they're not
#  Directly in the CR.

# Also, kroxy is never gonna be at infra level. We're probably gonna want to _use_ a gateway to expose Kafka off-kube
#  So there's a kind of decorate pattern going on where the GatewayClassConfig
#  is used to point to some other gateway, or Ingress, or whatever????